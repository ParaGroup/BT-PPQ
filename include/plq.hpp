/* -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */

/*! 
 *  \file plq.hpp
 *  \brief Pane-level Query Stage
 *  
 *  Implementation of the Pane-level Query (PLQ) stage, which consists in the
 *  first stage used by the Pane Farming pattern. PLQ is a farm in which the
 *  emitter is responsible to schedule tuples to the workers, analyze the stream
 *  and generate punctuations to deal with out-of-order tuples. Workers execute
 *  the working logic on the panes, where a tuple belongs to exactly one pane.
 *  Computed panes, eventually produced out-of-order, are transmitted to the
 *  next stage of Pane Farming (WLQ).
 *  
 */

/* ***************************************************************************
 *  
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *  
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 *  License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *  
 ****************************************************************************
 */

/*  Author: Gabriele Mencagli <mencagli@di.unipi.it>
 *  April 2016
 */

#ifndef PLQ_H
#define PLQ_H

// include
#include <math.h>
#include <deque>
#include <ff/lb.hpp>
#include <ff/node.hpp>
#include <ff/farm.hpp>
#include <ff/mapping_utils.hpp>
#include <kslack.hpp>
#include <tuple_t.hpp>
#include <general.hpp>
#include <queries.hpp>
#include <sched_plq.hpp>
#include <socket_utils.hpp>

using namespace ff;
using namespace std;

/* This file provides the following classes:
 *  -PLQ_Emitter: class that implements the emitter of the PLQ stage (OOP version);
 *  -PLQ_Emitter_IOP: class that implements a IOP version of the PLQ Emitter;
 *  -PLQ_Worker: class that implements the worker of the PLQ stage (OOP version);
 *  -PLQ_Worker_IOP: class that implements a IOP version of the worker of the PLQ stage.
 */

/*! 
 *  \class PLQ_Emitter
 *  
 *  \brief Emitter of the Pane-level Query Stage
 *  
 *  Emitter functionality of the PLQ stage of the Pane Farming. It is
 *  responsible to receive the tuples from the Generator, distributes them
 *  to the workers, and then evaluate the degree of disordering and
 *  produce punctuations to the workers to go on on their computations.
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
class PLQ_Emitter: public ff_node_t<tuple_t> {
private:
	int s; // input socket from the Generator
	unsigned long pane_length; // temporal length of a pane (in ms)
	unsigned int nw; // number of PLQ_Worker instances
	int port; // port to receive the connection from the Generator
	bool pidEnabled; // true if adaptive slack mechanism is enabled
	KSlack_Punc kslack; // standard slack punctuation mechanism
	KSlackPID_Punc kslackpid; // adaptive slack punctuation mechanism
    unsigned long rcv_sample = 0; // number of tuples received in the last sample
    unsigned long dropped_sample = 0; // number of tuples dropped in the last sample
    unsigned long dropped_total = 0; // total number of dropped tuples
    unsigned long rcv_total = 0; // total number of received tuples
    double last_P = 0; // value of the highest punctuation seen so far
	ff_loadbalancer * const lb; // load balancer object for the scheduling to workers
	size_t n_punc = 0; // number of punctuations generated by the PLQ emitter
	volatile ticks last_punct_time = 0; // time in ticks of the last punctuation
#if defined(PB_RR_SCHED)
	PB_RR_Sched *sched;
#elif defined(TB_RR_SCHED)
	TB_RR_Sched *sched;
#elif defined(ADAPTIVE_SCHED)
	Adaptive_Sched *sched;
#elif defined(ADAPTIVE_SCHED_PID)
	Adaptive_Sched_PID *sched;
#endif

public:
	// constructor
	PLQ_Emitter(unsigned long _len, size_t _nw, size_t _port, double _target_drop_prob, ff_loadbalancer * const _lb)
	            :pane_length(_len), nw(_nw), port(_port), pidEnabled(_target_drop_prob>0), kslackpid(_target_drop_prob), lb(_lb) {}

	// destructor
	~PLQ_Emitter() {
	    delete sched;
	}

	// svc_init method
	int svc_init() {
		// start connection with the Generator
		int *socket = socket_accept(1, port);
		s = *socket;
		MY_PRINT("Connection from Generator: OK\n");
		// entering the sampling barrier
		pthread_barrier_wait(&sampleBarr);
		volatile ticks starting_time = getticks();
#if defined(PB_RR_SCHED)
	sched = new PB_RR_Sched(nw, lb, starting_time);
#elif defined(TB_RR_SCHED)
	sched = new TB_RR_Sched(nw, lb, starting_time);
#elif defined(ADAPTIVE_SCHED)
	sched = new Adaptive_Sched(nw, lb, starting_time);
#elif defined(ADAPTIVE_SCHED_PID)
	sched = new Adaptive_Sched_PID(nw, lb, starting_time, desired_rho); // desired_rho is another global variable, to be removed!
#endif
		return 0;
	}

	// svc_end method
	void svc_end() {
		// close connection with the Generator
		close(s);
		// entering the printing barrier
		pthread_barrier_wait(&printBarr);
		MY_PRINT("***********************PLQ Emitter Statistics***********************\n" <<\
			      "Dropped: " << dropped_total << "/" << rcv_total << " tuples\n" <<\
			      "Splitting factor: " << sched->getSplitFactor() << "\n" <<\
			      "No. of punctuations transmitted: " << n_punc << "\n" <<\
			      "Load balancing ratio (PLQ stage): " << sched->getLBRatio() << "%%\n" <<\
			      "Average utilization (PLQ stage): " << sched->getAvgUtilization() << "\n" <<\
			      "********************************************************************\n");	
#if defined(PLQ_ONLY)
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
#else
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
		// entering the precedence barrier 2
		pthread_barrier_wait(&precBarr2);
#endif
	}

	// svc method
	tuple_t *svc(tuple_t *t) {
		char tuple_buffer[tuple_t::getSize()];
		// loop until the end of the stream
		while(socket_receive(s, tuple_buffer, tuple_t::getSize()) > 0) {
			rcv_sample++;
			rcv_total++;
			// create the tuple by deserializing the received data
			tuple_t *t = new tuple_t();
			t->deserialize(tuple_buffer);
			// set the time at which we have received the tuple
			t->arrival_ticks = getticks();
			// ###################################### START PUNCTUATION MECHANISM ####################################### //
			// case of the standard slack algorithm for punctuation generation
			if(!pidEnabled) {
				double new_punctuation;
				if(kslack.checkProgress(*t, new_punctuation)) {
					// if the time elapsed from the last punctuation is not too short
					if(FROM_TICKS_TO_USECS(getticks()-last_punct_time) >= MAX_TIME_BETWEEN_PUNC_USEC) {
						last_punct_time = getticks();
						n_punc++;
						// compute the pane id corresponding to the new punctuation value
						size_t pane_id = (size_t) (new_punctuation / (pane_length * 1000));
						// generate punctuation
						sched->generatePunctuation(new_punctuation, pane_id);		
					}
					if(new_punctuation > last_P) last_P = new_punctuation;
				}
			}
			// case of the adaptive slack algorithm for punctuation generation
			else {
				double drop_prob =  ((double) dropped_sample)/ ((double) rcv_sample);
				// adapt the slack mechanism
				if(kslackpid.adapt(drop_prob)) {
					// the sampling interval of the PID is finished, we reset the counters for the next one
					dropped_sample = rcv_sample = 0;
				}
				double new_punctuation;
				if(kslackpid.checkProgress(*t, new_punctuation)) {
					// if the time elapsed from the last punctuation is not too short
					if(FROM_TICKS_TO_USECS(getticks()-last_punct_time) >= MAX_TIME_BETWEEN_PUNC_USEC) {
						last_punct_time = getticks();
						n_punc++;
						// compute the pane id corresponding to the new punctuation value
						size_t pane_id = (size_t) (new_punctuation / (pane_length * 1000));
						// generate punctuation
						sched->generatePunctuation(new_punctuation, pane_id);
					}
					if(new_punctuation > last_P) last_P = new_punctuation;
				}
			}
			// ####################################### END PUNCTUATION MECHANISM ######################################## //
			// if the tuple must be dropped
			if(t->app_ts < last_P) {
				dropped_sample++;
				dropped_total++;
				delete t;
			}
			// if the tuple must be scheduled
			else {
				// ########################################## START SCHEDULING ########################################## //
				// set the id of the pane of the current tuple
				t->pane_id = (size_t) (t->app_ts / (pane_length * 1000));
				t->no_instances = 1; // by default we have one instance of the pane
				sched->sched_to_worker(t);
				// ########################################### END SCHEDULING ########################################### //
			}
		}
		// send the EOS marker to all the workers
		broadcast_EOS();
		return EOS;
	}

	// method to send a EOS to all the workers
	inline void broadcast_EOS() {
		// create the EOS tuple
		tuple_t *p = new tuple_t();
		p->set_EOS(nw);
		// broadcast the punctuation to the workers
		lb->broadcast_task(p);
	}
};

/*! 
 *  \class PLQ_Emitter_IOP
 *  
 *  \brief Emitter of the Pane-level Query Stage (IOP version)
 *  
 *  IOP (In-Order-Processing) version of the PLQ Emitter functionality.
 *  In this version the tuples are buffered and transmitted in order
 *  to the PLQ workers.
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
class PLQ_Emitter_IOP: public ff_node_t<tuple_t> {
private:
	int s; // input socket from the Generator
	unsigned long pane_length; // temporal length of a pane (in ms)
	unsigned int nw; // number of PLQ_Worker instances
	int port; // port to receive the connection from the Generator
	bool pidEnabled; // true if adaptive slack mechanism is enabled
	KSlack_Buffer buffer; // reordering buffer based on standard K-slack
	KSlackPID_Buffer bufferPID; // reordering buffer based on adaptive K-slack controlled by a PID
    unsigned long rcv_sample = 0; // number of tuples received in the last sample
    unsigned long dropped_sample = 0; // number of tuples dropped in the last sample
    unsigned long dropped_total = 0; // total number of dropped tuples
    unsigned long rcv_total = 0; // total number of received tuples
    unsigned long out_tuples = 0; // total number of tuples emitted out-of-order
    unsigned long n_extracted_tuples = 0; // total number of tuples extracted from the ordering buffer
    double avg_buffering_time = 0; // average buffering time of the tuples in the ordering buffer
    double last_timestamp = 0; // application timestamp of the last tuple scheduled to the PLQ workers
	ff_loadbalancer * const lb; // load balancer object for the scheduling to workers
	size_t n_tuples = 0; // number of tuples seen by the PLQ emitter
#if defined(PB_RR_SCHED)
	PB_RR_Sched *sched;
#elif defined(TB_RR_SCHED)
	TB_RR_Sched *sched;
#elif defined(ADAPTIVE_SCHED)
	Adaptive_Sched *sched;
#elif defined(ADAPTIVE_SCHED_PID)
	Adaptive_Sched_PID *sched;
#endif

public:
	// constructor
	PLQ_Emitter_IOP(unsigned long _len, size_t _nw, size_t _port, double _target_drop_prob, ff_loadbalancer * const _lb)
	            :pane_length(_len), nw(_nw), port(_port), pidEnabled(_target_drop_prob>0), bufferPID(_target_drop_prob), lb(_lb) {}

	// destructor
	~PLQ_Emitter_IOP() {
	    delete sched;
	}

	// svc_init method
	int svc_init() {
		// start connection with the Generator
		int *socket = socket_accept(1, port);
		s = *socket;
		MY_PRINT("Connection from Generator: OK\n");
		// entering the sampling barrier
		pthread_barrier_wait(&sampleBarr);
		volatile ticks starting_time = getticks();
#if defined(PB_RR_SCHED)
	sched = new PB_RR_Sched(nw, lb, starting_time, true);
#elif defined(TB_RR_SCHED)
	sched = new TB_RR_Sched(nw, lb, starting_time, true);
#elif defined(ADAPTIVE_SCHED)
	sched = new Adaptive_Sched(nw, lb, starting_time, true);
#elif defined(ADAPTIVE_SCHED_PID)
	sched = new Adaptive_Sched_PID(nw, lb, starting_time, desired_rho, true); // desired_rho is another global variable, to be removed!
#endif
		return 0;
	}

	// svc_end method
	void svc_end() {
		// close connection with the Generator
		close(s);
		// entering the printing barrier
		pthread_barrier_wait(&printBarr);
		// check whether there are some pending tuples in the k-slack buffer
		if(buffer.getSize() != 0) MY_PRINT("PLQ_Emitter_IOP has some pending tuples in buffer!\n");
		MY_PRINT("***********************PLQ Emitter_IOP Statistics***********************\n" <<\
			      "Out-of-Order tuples: " << out_tuples << "/" << rcv_total << " tuples\n" <<\
			      "Average Buffering Time: " << avg_buffering_time/1000 << " msec\n" <<\
			      "Splitting factor: " << sched->getSplitFactor() << "\n" <<\
			      "Load balancing ratio (PLQ stage): " << sched->getLBRatio() << "%%\n" <<\
			      "Average utilization (PLQ stage): " << sched->getAvgUtilization() << "\n" <<\
			      "************************************************************************\n");
#if defined(PLQ_ONLY)
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
#else
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
		// entering the precedence barrier 2
		pthread_barrier_wait(&precBarr2);
#endif
	}

	// svc method
	tuple_t *svc(tuple_t *t) {
		char tuple_buffer[tuple_t::getSize()];
		// loop until the end of the stream
		while(socket_receive(s, tuple_buffer, tuple_t::getSize()) > 0) {
			rcv_sample++;
			rcv_total++;
			// create the tuple by deserializing the received data
			tuple_t *t = new tuple_t();
			t->deserialize(tuple_buffer);
			// set the time at which we have received the tuple
			t->arrival_ticks = getticks();
			// ###################################### START MANAGEMENT OF THE SLACK BUFFER ####################################### //
			// insert the tuple in the buffer
			if(!pidEnabled) {
				buffer.insertTuple(t);
				// extract tuples from the buffer (likely in order)
				t = buffer.extractTuple();
			}
			else {
				bufferPID.insertTuple(t);
				// we adapt the delay of the adaptive K-slack buffer
				double drop_prob =  ((double) dropped_sample)/ ((double) rcv_sample);
				// adapt the slack mechanism
				if(bufferPID.adapt(drop_prob)) {
					// the sampling interval of the PID is finished, we reset the counters for the next one
					dropped_sample = rcv_sample = 0;
				}
				// extract tuples from the buffer (likely in order)
				t = bufferPID.extractTuple();
			}
			while(t != NULL) {
				// update the buffering time
				n_extracted_tuples++;
				avg_buffering_time += (1/ ((double) n_extracted_tuples)) * ((FROM_TICKS_TO_USECS(getticks() - t->arrival_ticks)) - avg_buffering_time);
				// if the tuple is not emitted in order we discard it
				if(t->app_ts < last_timestamp) {
					out_tuples++;
					dropped_sample++;
					dropped_total++;
					delete t;
				}
				// otherwise we schedule the tuple to the PLQ workers
				else {
					// update the timestamp of the last transmitted tuple
					last_timestamp = t->app_ts;
					// ########################################## START SCHEDULING ########################################## //
					// set the id of the pane of the current tuple
					t->pane_id = (size_t) (t->app_ts / (pane_length * 1000));
					// update the statistics for scheduling
					if(t->pane_id > 0) sched->generatePunctuation(t->app_ts, t->pane_id-1);
					t->no_instances = 1; // by default we have one instance of the pane
					sched->sched_to_worker(t);
					// ########################################### END SCHEDULING ########################################### //
				}
				if(!pidEnabled) t = buffer.extractTuple();
				else t = bufferPID.extractTuple();
			}
			// ####################################### EMD MANAGEMENT OF THE SLACK BUFFER ######################################## //
		}
		// flush the buffer
		tuple_t *next_tuple;
		if(!pidEnabled) {
			buffer.prepareToFlush();
			next_tuple = buffer.extractTuple();
		}
		else {
			bufferPID.prepareToFlush();
			next_tuple = bufferPID.extractTuple();
		}
		while(next_tuple != NULL) {
			// update the buffering time
			n_extracted_tuples++;
			avg_buffering_time += (1/ ((double) n_extracted_tuples)) * ((FROM_TICKS_TO_USECS(getticks() - next_tuple->arrival_ticks)) - avg_buffering_time);
			// if the tuple is not emitted in order we discard it
			if(next_tuple->app_ts < last_timestamp) {
				out_tuples++;
				delete next_tuple;
			}
			// otherwise we schedule the tuple to the PLQ workers
			else {
				// update the timestamp of the last transmitted tuple
				last_timestamp = next_tuple->app_ts;
				// ########################################## START SCHEDULING ########################################## //
				// set the id of the pane of the current tuple
				next_tuple->pane_id = (size_t) (next_tuple->app_ts / (pane_length * 1000));
				// update the statistics for scheduling
				if(next_tuple->pane_id > 0) sched->generatePunctuation(next_tuple->app_ts, next_tuple->pane_id-1);
				next_tuple->no_instances = 1; // by default we have one instance of the pane
				sched->sched_to_worker(next_tuple);
				// ########################################### END SCHEDULING ########################################### //
			}
			if(!pidEnabled) next_tuple = buffer.extractTuple();
			else next_tuple = bufferPID.extractTuple();
		}
		// send the EOS marker to all the workers
		broadcast_EOS();
		return EOS;
	}

	// method to send a EOS to all the workers
	inline void broadcast_EOS() {
		// create the EOS tuple
		tuple_t *p = new tuple_t();
		p->set_EOS(nw);
		// broadcast the punctuation to the workers
		lb->broadcast_task(p);
	}
};

/*! 
 *  \class PLQ_Worker
 *  
 *  \brief Worker of the Pane-level Query Stage
 *  
 *  Worker functionality of the PLQ stage of the Pane Farming pattern. It is
 *  responsible to receive the tuple messages from the Emitter, and to add them
 *  to the corresponding pane. Panes are computed incrementally.
 *  Punctuations received by the Emitter allow the Worker to close a subset
 *  of its panes by transmitting them to the next stage (WLQ).
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
template<typename Pane_t>
class PLQ_Worker: public ff_node_t<tuple_t, Pane_t> {
private:
	size_t wp; // window length in terms of number of panes
	size_t sp; // window slide in terms of number of panes
	unsigned long pane_length; // temporal length of a pane (in ms)
	deque<Pane_t *> paneSet; // deque of open panes
	Pane_t fakePane; // fake pane for the search algorithm
	// if LOG mode is enabled we need the following variables for statistics
#if defined(LOG)
	size_t rcv_tuples = 0; // no. of received regular tuples
	double avg_deque_size = 0; // average size of the deque
	size_t rcv_punctuations = 0; // no. of punctuations received
	size_t rcv_punc_closing = 0; // no. of punctuations that close at least one pane instance
	double avg_pane_closed = 0; // average number of pane instances closed per received closing punctuation
	double avg_proc_time = 0; // average processing time per tuple (in usec)
#endif

	// method to compute the number of windows containing the pane with id pane_id
	size_t countWindows(size_t pane_id) {
		// adjust the identifier (starting from 1 is better)
		double idx = pane_id + 1;
		size_t first;
		if(idx < wp) first = 1;
		else first = ceil((idx - wp) / sp) + 1;
		size_t last = ceil(idx / sp);
		return (first-last+1);
	}

public:
	// constructor
	PLQ_Worker(size_t _wp, size_t _sp, unsigned long _len): wp(_wp), sp(_sp), pane_length(_len) {}

	// destructor
	~PLQ_Worker() {}

	// svc_init method
	int svc_init() {
		return 0;
	}

	// svc_end method
	void svc_end() {
		// check whether there are some pending panes in deque
		if(paneSet.size() != 0) MY_PRINT("PLQ_Worker has some pending panes in deque!\n");
		// if LOG mode is enabled we write on the log file
#if defined(LOG)
		ostringstream stream;
 		stream << "********************************PLQ Worker " << this->get_my_id() << "********************************\n";
 		stream << "Received tuples: " << rcv_tuples << "\n";
 		stream << "Received punctuations: " << rcv_punctuations << "\n";
 		stream << "Average deque size: " << avg_deque_size << "\n";
 		stream << "Average pane instances closed per closing punct.: " << avg_pane_closed << "\n";
 		stream << "Average processing time per tuple (usec): " << avg_proc_time << "\n";
    	LOG_PLQ_WRITE(stream);
#endif
	}

	// svc method
	Pane_t *svc(tuple_t *t) {
		// the input tuple is a punctuation
		if(t->isPunctuation) {
			/* We do the following actions:
			   1- find all the closed panes;
			   2- each closed pane is transmitted to the next stage.
			*/
			fakePane.setId(t->pane_id);
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// if LOG mode is enabled we update the statistics
#if defined(LOG)
			rcv_punctuations++;
			avg_deque_size = avg_deque_size + (1/((double) rcv_punctuations)) * (paneSet.size() - avg_deque_size);
#endif
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Pane_t *l, Pane_t *r)
									   { return l->getId() < r->getId(); });
			size_t n_closed = 0; // no. of closed panes
			// all the closed panes are transmitted to the next stage
			for(auto p=paneSet.begin(); p<it; p++) {
				n_closed++;
				Pane_t *result = (*p);
				// set the closing time of the pane
				result->setClosingTime(getticks());
				while(!ff_node_t<tuple_t, Pane_t>::ff_send_out(result));
			}
			// check whether the punctuation has closed some panes
			if(it > paneSet.begin()) {
				rcv_punc_closing++;
				avg_pane_closed += (1/(double) rcv_punc_closing) * (n_closed - avg_pane_closed);
			}
			// remove the closed panes from the deque
			paneSet.erase(paneSet.begin(), it);
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
		// the input is the EOS marker
		else if(t->isEOS) {
			/* We do the following actions:
			   1- we empty the deque;
			   2- all the panes are transmitted to the next stage.
			*/
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// all the panes are transmitted to the next stage
			for(auto p=paneSet.begin(); p < paneSet.end(); p++) {
				Pane_t *result = (*p);
				// set the closing time of the pane
				result->setClosingTime(getticks());
				while(!ff_node_t<tuple_t, Pane_t>::ff_send_out(result));
			}
			// empty the deque
			paneSet.clear();
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
		// the input is a new_pane_instance message
		else if(t->isNewInstance) {
			/* We do the following actions:
			   1- we find the corresponding pane (it must exist!);
			   2- change the counter of instances of that pane.
			*/
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Pane_t *l, Pane_t *r)
									   { return l->getId() < r->getId(); });
			// if the pane does not exist abort
			if((it == paneSet.end()) || ((*it)->getId() != t->pane_id)) abort();
			else {
				(*it)->setNoInstances(t->no_instances);
				// atomically decrement the tuple's reference counter
				size_t old_cnt = (t->refCounter).fetch_sub(1);
				// if I am the last, I can destroy the tuple
				if(old_cnt == 1) delete t;
				return ff_node_t<tuple_t, Pane_t>::GO_ON;
			}
		}
		// the input is a regular tuple
		else {
			/* We do the following actions:
			   1- we find whether the pane exists otherwise we create it;
			   2- we add the tuple to the pane;
			   3- we update the pane.
			*/
			// search the pane in the paneSet
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Pane_t *l, Pane_t *r)
									   { return l->getId() < r->getId(); });
			Pane_t *pane;
			// if the pane is not present and it has the largest id
			if(it == paneSet.end()) {
				// compute the number of windows to which this pane belongs
				size_t cntWin = countWindows(t->pane_id);
				pane = new Pane_t(cntWin, t->pane_id, t->no_instances, pane_length);
				paneSet.push_back(pane);
			}
			// if the pane is not present and it goes in the middle of the deque
			else if((*it)->getId() != t->pane_id) {
				// compute the number of windows to which this pane belongs
				size_t cntWin = countWindows(t->pane_id);
				pane = new Pane_t(cntWin, t->pane_id, t->no_instances, pane_length);
				paneSet.insert(it, pane);
			}
			// if the pane already exists
			else {
				pane = *it;
			}
#if defined(LOG)
			rcv_tuples++;
			volatile ticks start_time = getticks();
#endif
			// add the tuple to the pane and compute it
			if(!t->isLull) pane->addComputeTuple(*t);
			else {
				volatile ticks time_now = getticks();
				pane->setStartingTime(time_now);
				pane->setEndingTime(time_now);
			}
#if defined(LOG)
			volatile ticks end_time = getticks();
			double elapsed_time = FROM_TICKS_TO_USECS(end_time - start_time);
			avg_proc_time += (1/(double) rcv_tuples) * (elapsed_time - avg_proc_time);
#endif
			// delete the regular tuple
			delete t;
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
	}
};

/*! 
 *  \class PLQ_Worker_IOP
 *  
 *  \brief Worker of the Pane-level Query Stage (IOP version)
 *  
 *  IOP (In-Order-Processing) version of the PLQ worker functionality.
 *  In this version the tuples are received in-order from the PLQ emitter.
 *  
 *  This class is defined in \ref Pane_Farming/include/plq.hpp
 */
template<typename Pane_t>
class PLQ_Worker_IOP: public ff_node_t<tuple_t, Pane_t> {
private:
	size_t wp; // window length in terms of number of panes
	size_t sp; // window slide in terms of number of panes
	unsigned long pane_length; // temporal length of a pane (in ms)
	deque<Pane_t *> paneSet; // deque of open panes
	Pane_t fakePane; // fake pane for the search algorithm
	// if LOG mode is enabled we need the following variables for statistics
#if defined(LOG)
	size_t rcv_tuples = 0; // no. of received regular tuples
	double avg_proc_time = 0; // average processing time per tuple (in usec)
#endif

	// method to compute the number of windows containing the pane with id pane_id
	size_t countWindows(size_t pane_id) {
		// adjust the identifier (starting from 1 is better)
		double idx = pane_id + 1;
		size_t first;
		if(idx < wp) first = 1;
		else first = ceil((idx - wp) / sp) + 1;
		size_t last = ceil(idx / sp);
		return (first-last+1);
	}

public:
	// constructor
	PLQ_Worker_IOP(size_t _wp, size_t _sp, unsigned long _len): wp(_wp), sp(_sp), pane_length(_len) {}

	// destructor
	~PLQ_Worker_IOP() {}

	// svc_init method
	int svc_init() {
		return 0;
	}

	// svc_end method
	void svc_end() {
		// check whether there are some pending panes in deque
		if(paneSet.size() != 0) MY_PRINT("PLQ_Worker has some pending panes in deque!\n");
		// if LOG mode is enabled we write on the log file
#if defined(LOG)
		ostringstream stream;
 		stream << "********************************PLQ Worker_IOP " << this->get_my_id() << "********************************\n";
 		stream << "Received tuples: " << rcv_tuples << "\n";
 		stream << "Average processing time per tuple (usec): " << avg_proc_time << "\n";
    	LOG_PLQ_WRITE(stream);
#endif
	}

	// svc method
	Pane_t *svc(tuple_t *t) {
		// if the input is the EOS marker
		if(t->isEOS) {
			/* We do the following actions:
			   1- we empty the deque;
			   2- all the panes are transmitted to the next stage.
			*/
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// all the panes are transmitted to the next stage
			for(auto p=paneSet.begin(); p < paneSet.end(); p++) {
				Pane_t *result = (*p);
				while(!ff_node_t<tuple_t, Pane_t>::ff_send_out(result));
			}
			// empty the deque
			paneSet.clear();
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
		// the input is a new_pane_instance message
		else if(t->isNewInstance) {
			/* We do the following actions:
			   1- we find the corresponding pane (it must exist!);
			   2- change the counter of instances of that pane.
			*/
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Pane_t *l, Pane_t *r)
									   { return l->getId() < r->getId(); });
			// if the pane does not exist abort
			if((it == paneSet.end()) || ((*it)->getId() != t->pane_id)) abort();
			else {
				(*it)->setNoInstances(t->no_instances);
				// atomically decrement the tuple's reference counter
				size_t old_cnt = (t->refCounter).fetch_sub(1);
				// if I am the last, I can destroy the tuple
				if(old_cnt == 1) delete t;
				return ff_node_t<tuple_t, Pane_t>::GO_ON;
			}
		}
		// the input is a regular tuple
		else {
			/* We do the following actions:
			   1- we find whether the pane exists otherwise we create it;
			   2- we add the tuple to the pane;
			   3- we update the pane;
			   4- all the previous panes can be closed (IOP).
			*/
			// search the pane in the paneSet
			fakePane.setId(t->pane_id);
			auto it = std::lower_bound(paneSet.begin(), paneSet.end(), &fakePane,
									   [](Pane_t *l, Pane_t *r)
									   { return l->getId() < r->getId(); });
			// all the previous panes can be closed (IOP)
			for(auto p=paneSet.begin(); p < it; p++) {
				Pane_t *result = (*p);
				while(!ff_node_t<tuple_t, Pane_t>::ff_send_out(result));
			}
			Pane_t *pane;
			// if the pane is not present
			if(it == paneSet.end()) {
				// compute the number of windows to which this pane belongs
				size_t cntWin = countWindows(t->pane_id);
				pane = new Pane_t(cntWin, t->pane_id, t->no_instances, pane_length);
				// remove the closed panes from the deque
				paneSet.erase(paneSet.begin(), it);
				paneSet.push_back(pane);
			}
			// if the pane already exists
			else {
				pane = *it;
			}
#if defined(LOG)
			rcv_tuples++;
			volatile ticks start_time = getticks();
#endif
			// add the tuple to the pane and compute it
			if(!t->isLull) pane->addComputeTuple(*t);
			else {
				volatile ticks time_now = getticks();
				pane->setStartingTime(time_now);
				pane->setEndingTime(time_now);
			}
			// set the closing time of the pane
			pane->setClosingTime(getticks());
#if defined(LOG)
			volatile ticks end_time = getticks();
			double elapsed_time = FROM_TICKS_TO_USECS(end_time - start_time);
			avg_proc_time += (1/(double) rcv_tuples) * (elapsed_time - avg_proc_time);
#endif
			// delete the regular tuple
			delete t;
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
	}
};

#endif
