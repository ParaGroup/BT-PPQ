/* -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */

/*! 
 *  \file wf.hpp
 *  \brief Window-Farming Parallel Query
 *  
 *  Implementation of the Window Farming (WF) version of the query processing.
 *  Each input tuple is scheduled by the emitter to multiple workers, one for
 *  each window that the tuple belongs to. Each worker produces results of
 *  windows that are transmitted to the collector that emits them in the correct
 *  order.
 *  
 */

/* ***************************************************************************
 *  
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *  
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 *  License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *  
 ****************************************************************************
 */

/*  Author: Gabriele Mencagli <mencagli@di.unipi.it>
 *  July 2016
 */

#ifndef WF_H
#define WF_H

// include
#include <math.h>
#include <deque>
#include <ff/lb.hpp>
#include <ff/node.hpp>
#include <ff/farm.hpp>
#include <kslack.hpp>
#include <tuple_t.hpp>
#include <general.hpp>
#include <queries.hpp>
#include <socket_utils.hpp>

using namespace ff;
using namespace std;

/* This file provides the following classes:
 *  -WF_Emitter: class that implements the emitter of the WF;
 *  -WF_Worker: class that implements the worker of the WF;
 *  -WF_Collector: class that implements the collector of the WF;
 *  -WF: class that implements the Window Farming.
 */

/*! 
 *  \class WF_Emitter
 *  
 *  \brief Emitter of the Window Farming
 *  
 *  Emitter functionality of the Window Farming. It is responsible to receive
 *  tuples from the Generator, distributes them to the workers, and then
 *  evaluate the degree of disordering and produce punctuations to the workers
 *  to go on on their computations.
 *  
 *  This class is defined in \ref Pane_Farming/include/wf.hpp
 */
class WF_Emitter: public ff_node_t<tuple_t> {
private:
	int s; // input socket from the Generator
	size_t w_len; // window length in ms
	size_t w_slide; // window slide in ms
	unsigned int nw; // number of WF_Worker instances
	int port; // port to receive the connection from the Generator
	bool pidEnabled; // true if adaptive slack mechanism is enabled
	KSlack_Punc kslack; // base slack punctuation mechanism
	KSlackPID_Punc kslackpid; // adaptive slack punctuation mechanism
    unsigned long rcv_sample = 0; // number of tuples received in the last sample
    unsigned long dropped_sample = 0; // number of tuples dropped in the last sample
    unsigned long dropped_total = 0; // total number of dropped tuples
    unsigned long rcv_total = 0; // total number of received tuples
    double last_P = 0; // value of the highest punctuation seen so far
	ff_loadbalancer * const lb; // load balancer object for the scheduling to workers
	size_t n_punc = 0; // number of punctuations generated by the WF emitter
	volatile ticks last_punct_time = 0; // time in ticks of the last punctuation

public:
	// constructor
	WF_Emitter(size_t _w_len, size_t _w_slide, size_t _nw, double _target_drop_prob, size_t _port, ff_loadbalancer * const _lb)
	            :w_len(_w_len), w_slide(_w_slide), nw(_nw), port(_port), pidEnabled(_target_drop_prob>0), kslackpid(_target_drop_prob), lb(_lb) {}

	// destructor
	~WF_Emitter() {}

	// svc_init method
	int svc_init() {
		// start connection with the Generator
		int *socket = socket_accept(1, port);
		s = *socket;
		MY_PRINT("Connection from Generator: OK\n");
		// entering the sampling barrier
		pthread_barrier_wait(&sampleBarr);
		volatile ticks starting_time = getticks();
		return 0;
	}

	// svc_end method
	void svc_end() {
		// close connection with the Generator
		close(s);
		// entering the printing barrier
		pthread_barrier_wait(&printBarr);
#if defined(LOG)
		MY_PRINT("***********************WF Emitter Statistics***********************\n" <<\
			      "Dropped: " << dropped_total << "/" << rcv_total << " tuples\n" <<\
			      "No. of punctuations transmitted: " << n_punc << "\n" <<\
			      "*******************************************************************\n");
#else
		MY_PRINT("***********************WF Emitter Statistics***********************\n" <<\
			      "Dropped: " << dropped_total << "/" << rcv_total << " tuples\n" <<\
			      "No. of punctuations transmitted: " << n_punc << "\n" <<\
			      "*******************************************************************\n");
#endif
		// entering the precedence barrier 1
		pthread_barrier_wait(&precBarr1);
	}

	// svc method
	tuple_t *svc(tuple_t *t) {
		char tuple_buffer[tuple_t::getSize()];
		// loop until the end of the stream
		while(socket_receive(s, tuple_buffer, tuple_t::getSize()) > 0) {
			rcv_sample++;
			rcv_total++;
			// create the tuple by deserializing the received data
			tuple_t *t = new tuple_t();
			t->deserialize(tuple_buffer);
			// set the time at which we have received the tuple (overwrite the generator timestamp)
			t->gen_ts = FROM_TICKS_TO_USECS(getticks());
			// ###################################### START PUNCTUATION MECHANISM ####################################### //
			// case of the base slack algorithm for punctuation generation
			if(!pidEnabled) {
				double new_punctuation;
				if(kslack.checkProgress(*t, new_punctuation)) {
					// if the time elapsed from the last punctuation is not too short
					if(FROM_TICKS_TO_USECS(getticks()-last_punct_time) > MAX_TIME_BETWEEN_PUNC_USEC) {
						n_punc++;
						last_punct_time = getticks();
						// compute the window id corresponding to the new punctuation value
						size_t win_id = ((new_punctuation - w_len*1000) / (w_slide*1000)) + 1;
						// broadcast the punctuation to all the WF workers
						broadcast_P(new_punctuation, win_id);
					}
					if(new_punctuation > last_P) last_P = new_punctuation;
				}
			}
			// case of the adaptive slack algorithm for punctuation generation
			else {
				double drop_prob =  ((double) dropped_sample)/ ((double) rcv_sample);
				// adapt the slack mechanism
				if(kslackpid.adapt(drop_prob)) {
					// the sampling interval of the PID is finished, we reset the counter for the next one
					dropped_sample = rcv_sample = 0;
				}
				double new_punctuation;
				if(kslackpid.checkProgress(*t, new_punctuation)) {
					// if the time elapsed from the last punctuation is not too short
					if(FROM_TICKS_TO_USECS(getticks()-last_punct_time) > MAX_TIME_BETWEEN_PUNC_USEC) {
						n_punc++;
						last_punct_time = getticks();
						// compute the window id corresponding to the new punctuation value
						size_t win_id = ((new_punctuation - w_len*1000) / (w_slide*1000)) + 1;
						// broadcast the punctuation to all the WF workers
						broadcast_P(new_punctuation, win_id);
					}
					if(new_punctuation > last_P) last_P = new_punctuation;
				}
			}
			// ####################################### END PUNCTUATION MECHANISM ######################################## //
			// if the tuple must be dropped
			if(t->app_ts < last_P) {
				dropped_sample++;
				dropped_total++;
				delete t;
			}
			// if the tuple must be scheduled
			else {
				// ########################################## START SCHEDULING ########################################## //
				// for each window of the tuple schedule it to the corresponding worker
				int first_id = ceil((t->app_ts - (w_len*1000))/(w_slide*1000));
				if(first_id < 0) first_id = 0;
				int last_id = ceil(t->app_ts/(w_slide*1000));
				for(int i=first_id; i<last_id; i++) {
					// copy the tuple
					tuple_t *my_t = new tuple_t(*t);
					// set the id of the window of the my tuple
					my_t->pane_id = i;
					my_t->no_instances = 1;
					// schedule the tuple to the corresponding worker
					while(!lb->ff_send_out_to(my_t, i % nw));
				}
				delete t;
				// ########################################### END SCHEDULING ########################################### //
			}
		}
		// send the EOS marker to all the workers
		broadcast_EOS();
		return EOS;
	}

	// method to send a punctuation to all the workers
	inline void broadcast_P(double ts, size_t w_id) {
		// create the punctuation
		tuple_t *p = new tuple_t();
		p->set_P(ts, w_id, nw);
		// broadcast the punctuation to the workers
		lb->broadcast_task(p);
	}

	// method to send a EOS to all the workers
	inline void broadcast_EOS() {
		// create the EOS tuple
		tuple_t *p = new tuple_t();
		p->set_EOS(nw);
		// broadcast the punctuation to the workers
		lb->broadcast_task(p);
	}
};

/*! 
 *  \class WF_Worker
 *  
 *  \brief Worker of the Window Farming
 *  
 *  Worker functionality of the Window Farming implementation. It is
 *  responsible to receive the tuple messages from the Emitter, and to process
 *  the tuples by adding them to the corresponding window. Windows can be computed
 *  incrementally or when the panes will be closed. Punctuations received by the
 *  Emitter allow the Worker to close a subset of its windows by transmitting them
 *  to the collector.
 *  
 *  This class is defined in \ref Pane_Farming/include/wf.hpp
 */
template<typename Pane_t>
class WF_Worker: public ff_node_t<tuple_t, Pane_t> {
private:
	size_t w_len; // window length in ms
	size_t w_slide; // window slide in ms
	deque<Pane_t *> winSet; // deque of open windows
	Pane_t fakeWin; // fake window for the search algorithm
	// if LOG mode is enabled we need the following variables for statistics
#if defined(LOG)
	size_t rcv_tuples = 0; // no. of received regular tuples
	double avg_deque_size = 0; // average size of the deque
	size_t rcv_punctuations = 0; // no. of punctuations received
	size_t rcv_punc_closing = 0; // no. of punctuations that close at least one pane instance
	double avg_win_closed = 0; // average number of window closed per received closing punctuation
	double avg_proc_time = 0; // average processing time per tuple (in usec)
#endif

public:
	// constructor
	WF_Worker(size_t _w_len, size_t _w_slide): w_len(_w_len), w_slide(_w_slide) {}

	// destructor
	~WF_Worker() {}

	// svc_init method
	int svc_init() {
		return 0;
	}

	// svc_end method
	void svc_end() {
		// check whether there are some pending windows in deque
		if(winSet.size() != 0) MY_PRINT("WF_Worker has some pending windows in deque!\n");
		// if LOG mode is enabled we write on the log file
#if defined(LOG)
		ostringstream stream;
 		stream << "********************************WF Worker " << this->get_my_id() << "********************************\n";
 		stream << "Received tuples: " << rcv_tuples << "\n";
 		stream << "Received punctuations: " << rcv_punctuations << "\n";
 		stream << "Average deque size: " << avg_deque_size << "\n";
 		stream << "Average windows closed per closing punct.: " << avg_win_closed << "\n";
 		stream << "Average processing time per tuple (usec): " << avg_proc_time << "\n";
    	LOG_WF_WRITE(stream);
#endif
	}

	// svc method
	Pane_t *svc(tuple_t *t) {
		// the input tuple is a punctuation
		if(t->isPunctuation) {
			/* We do the following actions:
			   1- find all the closed windows;
			   2- each closed window is transmitted to the collector
			*/
			fakeWin.setId(t->pane_id);
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// if LOG mode is enabled we update the statistics
#if defined(LOG)
			rcv_punctuations++;
			avg_deque_size = avg_deque_size + (1/((double) rcv_punctuations)) * (winSet.size() - avg_deque_size);
#endif
			auto it = std::lower_bound(winSet.begin(), winSet.end(), &fakeWin,
									   [](Pane_t *l, Pane_t *r)
									   { return l->getId() < r->getId(); });
			size_t n_closed = 0; // no. of closed windows
			// all the closed windows are transmitted to the next stage
			for(auto p=winSet.begin(); p<it; p++) {
				n_closed++;
				Pane_t *result = (*p);
				// set the closing time of the window
				result->setClosingTime(getticks());
				while(!ff_node_t<tuple_t, Pane_t>::ff_send_out(result));
			}
			// check whether the punctuation has closed some windows
			if(it > winSet.begin()) {
				rcv_punc_closing++;
				avg_win_closed += (1/(double) rcv_punc_closing) * (n_closed - avg_win_closed);
			}
			// remove the closed windows from the deque
			winSet.erase(winSet.begin(), it);
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
		// the input is the EOS marker
		else if(t->isEOS) {
			/* We do the following actions:
			   1- we empty the deque;
			   2- all the windows are transmitted to the next stage.
			*/
			// atomically decrement the tuple's reference counter
			size_t old_cnt = (t->refCounter).fetch_sub(1);
			// if I am the last, I can destroy the tuple
			if(old_cnt == 1) delete t;
			// all the windows are transmitted to the next stage
			for(auto p=winSet.begin(); p < winSet.end(); p++) {
				Pane_t *result = (*p);
				// set the closing time of the window
				result->setClosingTime(getticks());
				while(!ff_node_t<tuple_t, Pane_t>::ff_send_out(result));
			}
			// empty the deque
			winSet.clear();
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
		// the input is a regular tuple
		else {
			/* We do the following actions:
			   1- we find whether the window exists otherwise we create it;
			   2- we add the tuple to the window;
			   3- we update the pane.
			*/
			// search the pane in the winSet
			fakeWin.setId(t->pane_id);
			auto it = std::lower_bound(winSet.begin(), winSet.end(), &fakeWin,
									   [](Pane_t *l, Pane_t *r)
									   { return l->getId() < r->getId(); });
			Pane_t *pane;
			// if the window is not present and it has the largest id
			if(it == winSet.end()) {
				// create the window
				pane = new Pane_t(1, t->pane_id, t->no_instances, 1);
				winSet.push_back(pane);
			}
			// if the pane is not present and it goes in the middle of the deque
			else if((*it)->getId() != t->pane_id) {
				// create the window
				pane = new Pane_t(1, t->pane_id, t->no_instances, 1);
				winSet.insert(it, pane);
			}
			// if the pane already exists
			else {
				pane = *it;
			}
#if defined(LOG)
			rcv_tuples++;
			volatile ticks start_time = getticks();
#endif
			// add the tuple to the window and compute it
			pane->addComputeTuple(*t);
#if defined(LOG)
			volatile ticks end_time = getticks();
			double elapsed_time = FROM_TICKS_TO_USECS(end_time - start_time);
			avg_proc_time += (1/(double) rcv_tuples) * (elapsed_time - avg_proc_time);
#endif
			// delete the regular tuple
			delete t;
			return ff_node_t<tuple_t, Pane_t>::GO_ON;
		}
	}
};

/*! 
 *  \class WF_Collector
 *  
 *  \brief Collector of the Window Farming
 *  
 *  Collector functionality of the Window Farming. It is in charge of
 *  receiving the windows from the WF_Worker instances and producing
 *  them outside in the increasing order of their identifier.
 *  
 *  This class is defined in \ref Pane_Farming/include/wf.hpp
 */
template<typename Pane_t>
class WF_Collector: public ff_node_t<Pane_t> {
private:
	// identifier of the next window to transmit
	size_t next_win_id = 0; // window id starting from 0
	// deque of the windows received and buffered for ordering
	deque<Pane_t *> winSet;

public:
	// constructor
	WF_Collector() {}

	// destructor
	~WF_Collector() {}

	// svc_init method
	int svc_init() {
		return 0;
	}

	// svc_end method
	void svc_end() {
		// check whether there are some pending windows in deque
		if(winSet.size() != 0) MY_PRINT("WF_Collector has some pending windows in deque!\n");
	}

	// svc method
	Pane_t *svc(Pane_t *w) {
#if !defined(UNORDERING_COLLECTOR)
		// if the received window is the next one to transmit
		if(w->getId() == next_win_id) {
			next_win_id++;
			ff_node_t<Pane_t>::ff_send_out(w);
			if(winSet.size() > 0) {
				// check whether there are other windows to transmit
				auto it = winSet.begin() + 1;
				for(; it<winSet.end(); it++) {
					if((*it) == nullptr) break;
					else {
						next_win_id++;
						ff_node_t<Pane_t>::ff_send_out(*it);
					}
				}
				// erase the pointers to the transmitted windows in deque
				winSet.erase(winSet.begin(), it);
			}
		}
		// otherwise the window must be buffered
		else {
			if(w->getId() - next_win_id >= winSet.size()) {
				size_t old_size = winSet.size();
				size_t new_size = w->getId() - next_win_id + 1;
				winSet.resize(new_size, nullptr);
			}
			winSet[w->getId() - next_win_id] = w;
		}
		return ff_node_t<Pane_t>::GO_ON;
#else
		// simply forward the window to the next stage
		return w;
#endif
	}
};

/*! 
 *  \class WF
 *  
 *  \brief Window Farming
 *  
 *  Window Farming is a parallel pattern for window-based streaming computations.
 *  It consists in a farm in which windows are incrementally computed by multiple
 *  workers and window results are emitted ordered by a collector.
 *  
 *  This class is defined in \ref Pane_Farming/include/wf.hpp
 */
template<typename Pane_t>
class WF: public ff_farm<> {
private:
    typedef WF_Emitter wf_emitter_t;
    typedef WF_Worker<Pane_t> wf_worker_t;
    typedef WF_Collector<Pane_t> wf_collector_t;
	size_t nw; // parallelism degree
    wf_emitter_t *wf_emitter; // pointer to the emitter
    vector<ff_node *> wf_w_vect; // vector of pointers to workers
    wf_collector_t *wf_collector; // pointer to the collector

public:
    /**
     * \brief constructor I
     * 
     * \param _wlen window length (in ms)
     * \param _wslide window slide (in ms)
     * \param _nw parallelism degree
     * \param _drop_prob desired dropping probability (0 uses the base slack mechanism)
     * \param _port port to receive connection from the Generator
     * \param input_ch states the presence of input channel
     * 
     */
    WF(size_t _wlen, size_t _wslide, size_t _nw, double _drop_prob, size_t _port, bool input_ch=false): ff_farm<>(input_ch, DEF_IN_BUFF_ENTRIES, DEF_OUT_BUFF_ENTRIES, true, _nw), nw(_nw) {
        cout << "Dimensions per tuple: " << DIM << endl;
        // create the farm
        for(size_t i=0; i<nw; i++) wf_w_vect.push_back(new wf_worker_t(_wlen, _wslide));
        ff_farm<>::add_workers(wf_w_vect);
        wf_emitter = new wf_emitter_t(_wlen, _wslide, nw, _drop_prob, _port, this->getlb());
        ff_farm<>::add_emitter(wf_emitter);
        wf_collector = new wf_collector_t();
        ff_farm<>::add_collector(wf_collector);
    }

    // destructor
    ~WF() {/*
        delete wf_emitter;
        for(auto const &node: wf_w_vect) {
            wf_worker_t *w = static_cast<wf_worker_t *>(node);
            delete w;
        }
        delete wf_collector;*/
    }
};

#endif
